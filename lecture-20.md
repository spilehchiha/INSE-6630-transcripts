***Jeremy Clark:*** This will be the last lecture on Bitcoin itself, before we start looking at more general improvements of Bitcoin, leading to other blockchain solutions, like Ethereum.

But there are a few issues that I missed, going through; this is going to be a few quick issues or things that we didn't talk about that add up to a lecture of miscellaneous things.

Just to kick ourselves off, let's start thinking about a blockchain where we have, say, these three blocks that have been created and what all the miners are trying to do is, they're trying to create an extension to this particular block, and specifically what they're doing is they're pointing previous block at previous block, they have their transactions that they bundle together which is in the Merkle root, and they're running their knots like a counter, for example, and what they're looking for is that there'll be a current target that's defined and what they're hoping to do is to find a value that's smaller than the target.

Now the first thing I want do is I want to apologize for in the past videos, I wrote, even though I said it correctly in words, I wrote it incorrectly; I inverted the bigger than or equal to sign. What we want is we want the target to be bigger than this value, not the other way round; This is the correct notation. [...] Anyways, so this is what all the miners are doing.

[...] They're going to have a different Merkle root. For a variety of reasons, even if everything else is considered equal, (they choose the same transactions in the same order which is highly unlikely but possible), the Coinbase transaction though will be at least specified to their own addresses, and so different miners with different addresses or at least different collections of miners if they're in a pool or something like that, all the miners in a pool will be solving the exact same proof of work; But, for individual miners with their own keys, they're all going to have a different Coinbase transactions; when you hash that unto the Merkle root, it's going to result in a completely different Merkle root, therefore, the result will be that, everyone will be mining on a different value here.
Another thing that sometimes trips people up, is this:
Let's say that when this block was created, very quickly after, or maybe simultaneously and depending on where you were in the network, it was sort of a coin toss which you would hear about, there was another block which was created as well.
So, half of the network is here, trying to solve a block that extends this, in other words, the previous block, is pointing at this block, and the other half of the network is up here, and they're trying to extend this other block.

What will happen is, one of these two will win. Usually, maybe this repeats itself a couple of times. so both of these find blocks at largely the same time and since they've all heard about this block, every one in this %50 heard about this block first, then there's something about this %50, they're better connected to each other and so they might all hear about this block as well and similarly with this block here.
Maybe this sort of pattern -called a fork- does continue, but what we see is that it dies very very quickly. The probability that it extends past a couple of blocks is very very low and usually what happens is it gets resolved so the mechanics of how it'd get resolved is let's say for example this person wins so they now have the longest chain so obviously everyone who is working here will now be working on extending this block and all the people that are working here, as soon as they hear about this block, then they know that the chain that goes to the upper part of this diagram is longer than the chain on the bottom. It's longer by one block and so they'll all switch as well. They'll all go up here. This %50 will stay here and you'll get %100 of the network that's trying to extend this block. What happens to this block? It will get orphaned. Sometimes this whole process is called a reorganization, esp. if there's sort of a chain of a couple of blocks that get orphaned; then we might call it a reorg of the chain. But anyways, basically everyone switches here and then will continue. It is possible that we have these kinds of temporary forks, but generally forks resolve themselves quite quickly. So the rule of thumb is that in general, forks resolve themselves within six blocks; usually it's a lot less than six blocks. What we've seen in the past, empirically, you can look at the blockchain and see, you can't see it in the blockchain 'cause once they're orphaned, they're forgotten, but there are people who keep records of things that were proposed that weren't included in the final blockchain, and so what will happen is what you can see is that six blocks is a very generous amount of time. There have been a couple of cases of things that lasted longer than 6 blocks, but it wasn't because people were solving blocks simultaneously, it was because some other technical issue that was causing a fork, e.g. there were miners who had incompatible software and so they were seeing each others' blocks but they were thinking that they were invalid, half of them thought that they were valid because they had updated and half of them didn't, so anyways. that's a very interesting story that happened once, but anyways, it's not a story for today.
The other things is that, because of the consequence of this, what we do is we generally say that a transaction is confirmed after 6 blocks have been added on to the end. The number of blocks that have been added, usually called the number of confirmation, so if we have a transaction and we're sitting here, first off, the transaction starts just in the UTXO pool, so at this point in time, before this block is created, this transaction, we say has 0 cn=onfirmations (0-conf as the standard) and then when we're here,  we say it has one confirmation (1-conf), which means it's been put in a block.  Then if we're here,  then it has two confirmations  and eventually we will reach six confirmations  and then we'll say that that transaction is very unlikely to get orphaned because of some sort of reorganization.
So This is a heursitic, jut by consideration, looking empirically and it's just sort of a rule thst people tend to to follow. Now, does that mean that you're going to wait 6 blocks in order if you buy coffee, remember six blocks is sixty minutes, it's worth noting as well, on average.  So, this is actually quite a while for our transaction to be confirmed. Are you gonna wait 60 minutes for your coffee? No, probably not. But what's happening there is that the coffee shop is taking a risk; they're going to see that it's on the pool and yes, it's true that this transaction could go away and by the way there are ways we mentioned the double spending attack sort of comes back in a different form in Bitcoin

[???]

IN all of these cases, the coffee shop is basically taking a risk and 